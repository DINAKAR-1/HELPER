lifecycle 
useEffect(() => {...}, []) = componentDidMount

useEffect(() => {...}, [dep]) = componentDidUpdate

return () => {...} inside useEffect = componentWillUnmount
------------------------------------------------------------
1. What are React lifecycle phases?
Answer:
React components have three main phases (for class components):
Mounting â€“ component is created and inserted into DOM (constructor, render, componentDidMount).
Updating â€“ re-render due to props/state change (shouldComponentUpdate, render, componentDidUpdate).
Unmounting â€“ component is removed from DOM (componentWillUnmount).
ğŸ‘‰ For functional components with hooks, lifecycle is handled using useEffect with proper dependency arrays.
------------------------------------------------------------
2. Difference between functional and class components?
Answer:
Class components use ES6 classes, lifecycle methods, and this.
Functional components are plain JS functions that can use Hooks (useState, useEffect, etc.).
Since React 16.8+, functional components are preferred (cleaner, easier, faster).
------------------------------------------------------------
3. What are React Hooks? Why are they introduced?
Answer:
Hooks let you use state and lifecycle methods inside functional components.
Common hooks: useState, useEffect, useContext, useReducer, useMemo, useCallback.
Introduced because class components were harder to reuse logic, test, and manage. Hooks solved that by giving reusable stateful logic.
------------------------------------------------------------
4. Difference between useEffect and useLayoutEffect?
Answer:
useEffect: Runs after paint â†’ good for API calls, subscriptions.
useLayoutEffect: Runs before paint â†’ good for measuring DOM, synchronizing layout.
ğŸ‘‰ If you need to block the paint until calculations are done, use useLayoutEffect.
------------------------------------------------------------
5. What is Virtual DOM and how React uses it?
Answer:
Virtual DOM = lightweight in-memory copy of real DOM.
On state/prop change â†’ React creates a new Virtual DOM â†’ diffs it with old one (diffing algo) â†’ updates only changed parts in real DOM.
ğŸ‘‰ This makes React fast compared to manual DOM manipulations.
------------------------------------------------------------
6. What is prop drilling and how to avoid it?
Answer:
Prop drilling = passing props through multiple layers just to reach a deeply nested component.
Avoid with:
Context API
Redux / Zustand / Recoil
Custom hooks
------------------------------------------------------------
7. What is React Context API?
Answer:
A way to manage global state without prop drilling.
Example:
const MyContext = React.createContext();
function App() {
  return (
    <MyContext.Provider value="Dinakar Rocks ğŸš€">
      <Child />
    </MyContext.Provider>
  );
}

function Child() {
  const value = React.useContext(MyContext);
  return <h1>{value}</h1>;
}
------------------------------------------------------------
8. What is memoization in React?
Answer:
Memoization = caching expensive calculations to avoid re-computation.
In React:
React.memo â†’ memoizes components.
useMemo â†’ memoizes values.
useCallback â†’ memoizes functions.
ğŸ‘‰ Helps with performance optimization.
------------------------------------------------------------
9. Whatâ€™s the difference between controlled and uncontrolled components?
Answer:
Controlled: Form data managed by React state.
<input value={name} onChange={e => setName(e.target.value)} />
Uncontrolled: Form data handled by DOM itself using ref.
<input ref={inputRef} />
------------------------------------------------------------
10. What are React keys and why are they important?
Answer:
Keys help React identify which items changed in a list.
Without keys â†’ React may re-render unnecessarily â†’ performance issues.
Rule: Use unique and stable keys (like id, not index unless static).
------------------------------------------------------------
11. Whatâ€™s the difference between useState and useReducer?
Answer:
useState â†’ simple state, small logic.
useReducer â†’ complex state transitions, like Redux but local.
const [state, dispatch] = useReducer(reducer, initialState);
------------------------------------------------------------
12. How do you optimize a React app?
Answer:
Use React.memo, useMemo, useCallback.
Lazy loading (React.lazy + Suspense).
Code splitting with Webpack.
Virtualization (react-window, react-virtualized).
Avoid anonymous functions inside render.
Pagination & infinite scrolling instead of rendering huge lists.
------------------------------------------------------------
13. What are Higher Order Components (HOC)?
Answer:
A pattern to reuse component logic.
Takes a component â†’ returns a new component with extra props/logic.
function withLogger(WrappedComponent) {
  return function Enhanced(props) {
    console.log("Props:", props);
    return <WrappedComponent {...props} />;
  };
}
------------------------------------------------------------
14. What is React Router and difference between BrowserRouter vs HashRouter?
Answer:
React Router = library for navigation.
BrowserRouter â†’ uses HTML5 history API (/home).
HashRouter â†’ uses hash fragment (#/home).
ğŸ‘‰ BrowserRouter is cleaner; HashRouter is useful when server doesnâ€™t support dynamic routes.
------------------------------------------------------------
15. Real-time scenario: How would you handle an API failure in React?
Answer:
Show loading spinner, error message, and allow retry.
Use try-catch or catch in fetch/axios.
Example:
try {
  const data = await fetch("/api/data").then(r => r.json());
  setData(data);
} catch (error) {
  setError("Failed to load data, please retry.");
}
------------------------------------------------------------
6. What is reconciliation in React?
Answer:
Reconciliation = Reactâ€™s process of updating the DOM when state/props change.
React compares the new Virtual DOM with the old one â†’ applies only minimal changes to real DOM.
ğŸ‘‰ Thatâ€™s why React is fast and efficient.
------------------------------------------------------------
17. Whatâ€™s the difference between React.Fragment and a <div> wrapper?
Answer:
Both group elements, but:
<div> â†’ adds extra node to DOM.
<React.Fragment> â†’ groups children without extra node.
return (
  <>
    <h1>Hello</h1>
    <p>World</p>
  </>
);
ğŸ‘‰ Useful when avoiding unnecessary div soup.
------------------------------------------------------------
18. What is the difference between useMemo and useCallback?
Answer:
useMemo â†’ memoizes a value.
useCallback â†’ memoizes a function.
const memoizedValue = useMemo(() => expensiveCalc(num), [num]);
const memoizedFn = useCallback(() => doSomething(num), [num]);
------------------------------------------------------------
19. What is lazy loading in React?
Answer:
Load components only when needed, not all at once.
const About = React.lazy(() => import("./About"));
Use with <Suspense fallback={<Loader />}>.
ğŸ‘‰ Improves initial load time (perf boost ğŸ’¨).
------------------------------------------------------------
20. How does React handle forms differently from vanilla JS?
Answer:
React keeps form inputs in state (controlled components).
Vanilla JS â†’ you fetch values from DOM (document.getElementById).
ğŸ‘‰ Controlled = predictable state, easier validation.
------------------------------------------------------------
21. What is Redux and when would you use it?
Answer:
Redux = predictable state container for React.
Use when:
Many components need shared state.
You want centralized control (logging, debugging, persistence).
Core concepts: store, actions, reducers.
ğŸ‘‰ But if your app is small â†’ Context API is enough.
------------------------------------------------------------
22. What is the difference between Redux and Context API?
Answer:
Context API: simple global state, works well for small-medium apps.
Redux: more powerful â†’ middleware, time-travel debugging, async handling.
ğŸ‘‰ Interview tip: Say â€œIâ€™d start with Context, but if the app grows large with complex state, Iâ€™d migrate to Redux.â€
------------------------------------------------------------
23. What is the difference between client-side and server-side rendering in React?
Answer:
Client-side rendering (CSR):
Browser loads empty HTML â†’ React renders everything with JS.
Faster navigation, slower first load.
Server-side rendering (SSR):
Server sends pre-rendered HTML â†’ React hydrates on client.
Faster initial load, better SEO.
ğŸ‘‰ Example: Next.js supports SSR out of the box.
------------------------------------------------------------
24. What is hydration in React?
Answer:
After SSR sends HTML â†’ React attaches event listeners and makes it interactive.
This process is called hydration.
------------------------------------------------------------
25. What are error boundaries in React?
Answer:
Special components that catch JS errors in child components.
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  static getDerivedStateFromError() { return { hasError: true }; }
  render() { return this.state.hasError ? "Something broke" : this.props.children; }
}
ğŸ‘‰ Prevents whole app crash, shows fallback UI.
------------------------------------------------------------
26. What are portals in React?
Answer:
Way to render children into a different DOM node outside parent hierarchy.
ReactDOM.createPortal(<Modal />, document.getElementById("modal-root"));
ğŸ‘‰ Useful for modals, tooltips, popups.\
------------------------------------------------------------
27. Whatâ€™s the difference between useRef and createRef?
Answer:
createRef â†’ creates new ref every render (used in class comps).
useRef â†’ persists across renders (used in function comps).
ğŸ‘‰ useRef is like a â€œboxâ€ that survives re-renders.
------------------------------------------------------------
28. What is the difference between useEffect(() => {}, []) and useEffect(() => {})?
Answer:
[] â†’ runs only once (on mount).
No [] â†’ runs after every render.
[dep] â†’ runs when dep changes.
ğŸ‘‰ This is the classic â€œgotchaâ€ question.
------------------------------------------------------------
29. What are controlled vs uncontrolled side effects?
Answer:
Controlled = predictable, inside useEffect.
Uncontrolled = outside Reactâ€™s lifecycle (like manually updating DOM, timers).
ğŸ‘‰ Always prefer controlled side effects.
------------------------------------------------------------
30. Real-time scenario: How would you handle performance issues in a React app with huge lists?
Answer:
Use windowing/virtualization â†’ react-window, react-virtualized.
Pagination / infinite scroll.
Memoize child components.
ğŸ‘‰ Instead of rendering 10,000 rows, only render whatâ€™s visible.
------------------------------------------------------------
-===========================
1. What is Redux and why do we use it?
Answer:
Redux = predictable state container for JS apps.
State is centralized in a single store.
Components dispatch actions, reducers update state, and UI re-renders.
ğŸ‘‰ Used when state needs to be shared across many components (think user auth, cart, theme).
------------------------------------------------------------
2. Core principles of Redux?
Answer:
Single source of truth â†’ one store holds entire app state.
State is read-only â†’ only changed by dispatching actions.
Changes via pure functions â†’ reducers are pure functions that return new state.
3. Explain Redux flow in simple steps.
Answer:
User does something â†’ dispatch(action).
Reducer takes current state + action â†’ returns new state.
Store updates and notifies subscribers.
React components subscribed via useSelector re-render.
ğŸ‘‰ Basically: UI â†’ Action â†’ Reducer â†’ Store â†’ UI again ğŸ”„
------------------------------------------------------------
4. What are actions in Redux?
Answer:
Objects that describe what happened.
Must have a type property.
{ type: "INCREMENT", payload: 1 }
------------------------------------------------------------
5. What are reducers?
Answer:
Pure functions that take (state, action) and return new state.
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case "INCREMENT": return { count: state.count + 1 };
    default: return state;
  }
}
------------------------------------------------------------
6. What is a Redux store?
Answer:
The single object holding app state.
Created with createStore (legacy) or configureStore (Redux Toolkit).
import { configureStore } from "@reduxjs/toolkit";
const store = configureStore({ reducer: counterReducer });
------------------------------------------------------------
7. Difference between Redux and Context API?
Answer:
Context API â†’ small apps, light global state.
Redux â†’ large apps, advanced debugging, async flows, middleware.
ğŸ‘‰ Interview tip: â€œIâ€™d use Context for small global state, Redux when app scales with complex state.â€
------------------------------------------------------------
8. What is Redux Thunk?
Answer:
Middleware that lets you write async logic in Redux.
Normally actions must return plain objects, but Thunk lets actions return a function.
function fetchUsers() {
  return async (dispatch) => {
    dispatch({ type: "FETCH_START" });
    const res = await fetch("/users");
    const data = await res.json();
    dispatch({ type: "FETCH_SUCCESS", payload: data });
  };
}
------------------------------------------------------------
9. Redux vs Redux Toolkit?
Answer:
Redux (old way):
Lots of boilerplate â†’ actions, constants, reducers, switch cases.
Redux Toolkit (RTK):
Opinionated, less boilerplate, includes createSlice, built-in Thunk.
const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1; }
  }
});
ğŸ‘‰ RTK is the recommended way now.
------------------------------------------------------------
10. What are selectors in Redux?
Answer:
Functions to extract specific state from store.
Helps avoid repeating logic.
const selectCount = (state) => state.counter.value;
------------------------------------------------------------
11. Difference between synchronous and asynchronous actions in Redux?
Answer:
Sync actions: return plain object immediately ({ type, payload }).
Async actions: involve API calls, use middleware (Thunk, Saga).
------------------------------------------------------------
12. Whatâ€™s Redux Saga and how is it different from Thunk?
Answer:
Thunk: async logic inside functions, easier, beginner-friendly.
Saga: uses generators for complex async flows, good for large apps.
ğŸ‘‰ If interviewer asks, say â€œThunk is enough for most apps, Saga when you need advanced async orchestration.â€
------------------------------------------------------------
13. Real-time scenario: How would you persist Redux state after page refresh?
Answer:
Use redux-persist library.
It saves state to localStorage/sessionStorage and rehydrates on reload.
------------------------------------------------------------
14. What happens if reducers are not pure functions?
Answer:
State mutations, unpredictable behavior, broken time-travel debugging, side effects.
ğŸ‘‰ Reducers must be pure.
------------------------------------------------------------
15. Can you explain middleware in Redux?
Answer:
Middleware = function that sits between dispatching action and reaching reducer.
Example: logging, async calls, error handling.
const logger = store => next => action => {
  console.log("Dispatching", action);
  return next(action);
};
------------------------------------------------------------