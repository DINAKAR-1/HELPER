lifecycle 
useEffect(() => {...}, []) = componentDidMount

useEffect(() => {...}, [dep]) = componentDidUpdate

return () => {...} inside useEffect = componentWillUnmount

1. What are React lifecycle phases?

Answer:
React components have three main phases (for class components):

Mounting â€“ component is created and inserted into DOM (constructor, render, componentDidMount).

Updating â€“ re-render due to props/state change (shouldComponentUpdate, render, componentDidUpdate).

Unmounting â€“ component is removed from DOM (componentWillUnmount).

ğŸ‘‰ For functional components with hooks, lifecycle is handled using useEffect with proper dependency arrays.

2. Difference between functional and class components?

Answer:

Class components use ES6 classes, lifecycle methods, and this.

Functional components are plain JS functions that can use Hooks (useState, useEffect, etc.).

Since React 16.8+, functional components are preferred (cleaner, easier, faster).

3. What are React Hooks? Why are they introduced?

Answer:

Hooks let you use state and lifecycle methods inside functional components.

Common hooks: useState, useEffect, useContext, useReducer, useMemo, useCallback.

Introduced because class components were harder to reuse logic, test, and manage. Hooks solved that by giving reusable stateful logic.

4. Difference between useEffect and useLayoutEffect?

Answer:

useEffect: Runs after paint â†’ good for API calls, subscriptions.

useLayoutEffect: Runs before paint â†’ good for measuring DOM, synchronizing layout.
ğŸ‘‰ If you need to block the paint until calculations are done, use useLayoutEffect.

5. What is Virtual DOM and how React uses it?

Answer:

Virtual DOM = lightweight in-memory copy of real DOM.

On state/prop change â†’ React creates a new Virtual DOM â†’ diffs it with old one (diffing algo) â†’ updates only changed parts in real DOM.
ğŸ‘‰ This makes React fast compared to manual DOM manipulations.

6. What is prop drilling and how to avoid it?

Answer:

Prop drilling = passing props through multiple layers just to reach a deeply nested component.

Avoid with:

Context API

Redux / Zustand / Recoil

Custom hooks

7. What is React Context API?

Answer:

A way to manage global state without prop drilling.

Example:

const MyContext = React.createContext();

function App() {
  return (
    <MyContext.Provider value="Dinakar Rocks ğŸš€">
      <Child />
    </MyContext.Provider>
  );
}

function Child() {
  const value = React.useContext(MyContext);
  return <h1>{value}</h1>;
}

8. What is memoization in React?

Answer:

Memoization = caching expensive calculations to avoid re-computation.

In React:

React.memo â†’ memoizes components.

useMemo â†’ memoizes values.

useCallback â†’ memoizes functions.
ğŸ‘‰ Helps with performance optimization.

9. Whatâ€™s the difference between controlled and uncontrolled components?

Answer:

Controlled: Form data managed by React state.

<input value={name} onChange={e => setName(e.target.value)} />


Uncontrolled: Form data handled by DOM itself using ref.

<input ref={inputRef} />

10. What are React keys and why are they important?

Answer:

Keys help React identify which items changed in a list.

Without keys â†’ React may re-render unnecessarily â†’ performance issues.

Rule: Use unique and stable keys (like id, not index unless static).

11. Whatâ€™s the difference between useState and useReducer?

Answer:

useState â†’ simple state, small logic.

useReducer â†’ complex state transitions, like Redux but local.

const [state, dispatch] = useReducer(reducer, initialState);

12. How do you optimize a React app?

Answer:

Use React.memo, useMemo, useCallback.

Lazy loading (React.lazy + Suspense).

Code splitting with Webpack.

Virtualization (react-window, react-virtualized).

Avoid anonymous functions inside render.

Pagination & infinite scrolling instead of rendering huge lists.

13. What are Higher Order Components (HOC)?

Answer:

A pattern to reuse component logic.

Takes a component â†’ returns a new component with extra props/logic.

function withLogger(WrappedComponent) {
  return function Enhanced(props) {
    console.log("Props:", props);
    return <WrappedComponent {...props} />;
  };
}

14. What is React Router and difference between BrowserRouter vs HashRouter?

Answer:

React Router = library for navigation.

BrowserRouter â†’ uses HTML5 history API (/home).

HashRouter â†’ uses hash fragment (#/home).
ğŸ‘‰ BrowserRouter is cleaner; HashRouter is useful when server doesnâ€™t support dynamic routes.

15. Real-time scenario: How would you handle an API failure in React?

Answer:

Show loading spinner, error message, and allow retry.

Use try-catch or catch in fetch/axios.

Example:

try {
  const data = await fetch("/api/data").then(r => r.json());
  setData(data);
} catch (error) {
  setError("Failed to load data, please retry.");
}
6. What is reconciliation in React?

Answer:

Reconciliation = Reactâ€™s process of updating the DOM when state/props change.

React compares the new Virtual DOM with the old one â†’ applies only minimal changes to real DOM.
ğŸ‘‰ Thatâ€™s why React is fast and efficient.

17. Whatâ€™s the difference between React.Fragment and a <div> wrapper?

Answer:

Both group elements, but:

<div> â†’ adds extra node to DOM.

<React.Fragment> â†’ groups children without extra node.

return (
  <>
    <h1>Hello</h1>
    <p>World</p>
  </>
);


ğŸ‘‰ Useful when avoiding unnecessary div soup.

18. What is the difference between useMemo and useCallback?

Answer:

useMemo â†’ memoizes a value.

useCallback â†’ memoizes a function.

const memoizedValue = useMemo(() => expensiveCalc(num), [num]);
const memoizedFn = useCallback(() => doSomething(num), [num]);

19. What is lazy loading in React?

Answer:

Load components only when needed, not all at once.

const About = React.lazy(() => import("./About"));


Use with <Suspense fallback={<Loader />}>.
ğŸ‘‰ Improves initial load time (perf boost ğŸ’¨).

20. How does React handle forms differently from vanilla JS?

Answer:

React keeps form inputs in state (controlled components).

Vanilla JS â†’ you fetch values from DOM (document.getElementById).
ğŸ‘‰ Controlled = predictable state, easier validation.

21. What is Redux and when would you use it?

Answer:

Redux = predictable state container for React.

Use when:

Many components need shared state.

You want centralized control (logging, debugging, persistence).

Core concepts: store, actions, reducers.
ğŸ‘‰ But if your app is small â†’ Context API is enough.

22. What is the difference between Redux and Context API?

Answer:

Context API: simple global state, works well for small-medium apps.

Redux: more powerful â†’ middleware, time-travel debugging, async handling.
ğŸ‘‰ Interview tip: Say â€œIâ€™d start with Context, but if the app grows large with complex state, Iâ€™d migrate to Redux.â€

23. What is the difference between client-side and server-side rendering in React?

Answer:

Client-side rendering (CSR):

Browser loads empty HTML â†’ React renders everything with JS.

Faster navigation, slower first load.

Server-side rendering (SSR):

Server sends pre-rendered HTML â†’ React hydrates on client.

Faster initial load, better SEO.

ğŸ‘‰ Example: Next.js supports SSR out of the box.

24. What is hydration in React?

Answer:

After SSR sends HTML â†’ React attaches event listeners and makes it interactive.

This process is called hydration.

25. What are error boundaries in React?

Answer:

Special components that catch JS errors in child components.

class ErrorBoundary extends React.Component {
  state = { hasError: false };
  static getDerivedStateFromError() { return { hasError: true }; }
  render() { return this.state.hasError ? "Something broke" : this.props.children; }
}


ğŸ‘‰ Prevents whole app crash, shows fallback UI.

26. What are portals in React?

Answer:

Way to render children into a different DOM node outside parent hierarchy.

ReactDOM.createPortal(<Modal />, document.getElementById("modal-root"));


ğŸ‘‰ Useful for modals, tooltips, popups.

27. Whatâ€™s the difference between useRef and createRef?

Answer:

createRef â†’ creates new ref every render (used in class comps).

useRef â†’ persists across renders (used in function comps).
ğŸ‘‰ useRef is like a â€œboxâ€ that survives re-renders.

28. What is the difference between useEffect(() => {}, []) and useEffect(() => {})?

Answer:

[] â†’ runs only once (on mount).

No [] â†’ runs after every render.

[dep] â†’ runs when dep changes.
ğŸ‘‰ This is the classic â€œgotchaâ€ question.

29. What are controlled vs uncontrolled side effects?

Answer:

Controlled = predictable, inside useEffect.

Uncontrolled = outside Reactâ€™s lifecycle (like manually updating DOM, timers).
ğŸ‘‰ Always prefer controlled side effects.

30. Real-time scenario: How would you handle performance issues in a React app with huge lists?

Answer:

Use windowing/virtualization â†’ react-window, react-virtualized.

Pagination / infinite scroll.

Memoize child components.
ğŸ‘‰ Instead of rendering 10,000 rows, only render whatâ€™s visible.
