lifecycle 
useEffect(() => {...}, []) = componentDidMount

useEffect(() => {...}, [dep]) = componentDidUpdate

return () => {...} inside useEffect = componentWillUnmount

1. What are React lifecycle phases?

Answer:
React components have three main phases (for class components):

Mounting â€“ component is created and inserted into DOM (constructor, render, componentDidMount).

Updating â€“ re-render due to props/state change (shouldComponentUpdate, render, componentDidUpdate).

Unmounting â€“ component is removed from DOM (componentWillUnmount).

ðŸ‘‰ For functional components with hooks, lifecycle is handled using useEffect with proper dependency arrays.

2. Difference between functional and class components?

Answer:

Class components use ES6 classes, lifecycle methods, and this.

Functional components are plain JS functions that can use Hooks (useState, useEffect, etc.).

Since React 16.8+, functional components are preferred (cleaner, easier, faster).

3. What are React Hooks? Why are they introduced?

Answer:

Hooks let you use state and lifecycle methods inside functional components.

Common hooks: useState, useEffect, useContext, useReducer, useMemo, useCallback.

Introduced because class components were harder to reuse logic, test, and manage. Hooks solved that by giving reusable stateful logic.

4. Difference between useEffect and useLayoutEffect?

Answer:

useEffect: Runs after paint â†’ good for API calls, subscriptions.

useLayoutEffect: Runs before paint â†’ good for measuring DOM, synchronizing layout.
ðŸ‘‰ If you need to block the paint until calculations are done, use useLayoutEffect.

5. What is Virtual DOM and how React uses it?

Answer:

Virtual DOM = lightweight in-memory copy of real DOM.

On state/prop change â†’ React creates a new Virtual DOM â†’ diffs it with old one (diffing algo) â†’ updates only changed parts in real DOM.
ðŸ‘‰ This makes React fast compared to manual DOM manipulations.

6. What is prop drilling and how to avoid it?

Answer:

Prop drilling = passing props through multiple layers just to reach a deeply nested component.

Avoid with:

Context API

Redux / Zustand / Recoil

Custom hooks

7. What is React Context API?

Answer:

A way to manage global state without prop drilling.

Example:

const MyContext = React.createContext();

function App() {
  return (
    <MyContext.Provider value="Dinakar Rocks ðŸš€">
      <Child />
    </MyContext.Provider>
  );
}

function Child() {
  const value = React.useContext(MyContext);
  return <h1>{value}</h1>;
}

8. What is memoization in React?

Answer:

Memoization = caching expensive calculations to avoid re-computation.

In React:

React.memo â†’ memoizes components.

useMemo â†’ memoizes values.

useCallback â†’ memoizes functions.
ðŸ‘‰ Helps with performance optimization.

9. Whatâ€™s the difference between controlled and uncontrolled components?

Answer:

Controlled: Form data managed by React state.

<input value={name} onChange={e => setName(e.target.value)} />


Uncontrolled: Form data handled by DOM itself using ref.

<input ref={inputRef} />

10. What are React keys and why are they important?

Answer:

Keys help React identify which items changed in a list.

Without keys â†’ React may re-render unnecessarily â†’ performance issues.

Rule: Use unique and stable keys (like id, not index unless static).

11. Whatâ€™s the difference between useState and useReducer?

Answer:

useState â†’ simple state, small logic.

useReducer â†’ complex state transitions, like Redux but local.

const [state, dispatch] = useReducer(reducer, initialState);

12. How do you optimize a React app?

Answer:

Use React.memo, useMemo, useCallback.

Lazy loading (React.lazy + Suspense).

Code splitting with Webpack.

Virtualization (react-window, react-virtualized).

Avoid anonymous functions inside render.

Pagination & infinite scrolling instead of rendering huge lists.

13. What are Higher Order Components (HOC)?

Answer:

A pattern to reuse component logic.

Takes a component â†’ returns a new component with extra props/logic.

function withLogger(WrappedComponent) {
  return function Enhanced(props) {
    console.log("Props:", props);
    return <WrappedComponent {...props} />;
  };
}

14. What is React Router and difference between BrowserRouter vs HashRouter?

Answer:

React Router = library for navigation.

BrowserRouter â†’ uses HTML5 history API (/home).

HashRouter â†’ uses hash fragment (#/home).
ðŸ‘‰ BrowserRouter is cleaner; HashRouter is useful when server doesnâ€™t support dynamic routes.

15. Real-time scenario: How would you handle an API failure in React?

Answer:

Show loading spinner, error message, and allow retry.

Use try-catch or catch in fetch/axios.

Example:

try {
  const data = await fetch("/api/data").then(r => r.json());
  setData(data);
} catch (error) {
  setError("Failed to load data, please retry.");
}
