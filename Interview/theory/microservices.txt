Common Microservices Interview Questions (2 Years Exp)
1. What are microservices and why do we use them?

Answer:
Microservices are an architectural style where an application is split into small, independent services that communicate via APIs (usually REST or messaging).

Each service is loosely coupled, independently deployable, and focuses on one business capability.

Benefits: scalability, faster deployments, fault isolation, technology flexibility.

‚ö° Roast check: If you say "microservices = small code files", the interviewer will cancel your return Uber ride.

2. How do microservices communicate with each other?

Answer:

Sync: REST (HTTP), gRPC

Async: Kafka, RabbitMQ, ActiveMQ (message queues)

Async is often preferred for decoupling & reliability.

üí° Example: In an e-commerce app: Order Service sends an "OrderCreated" event to Kafka ‚Üí Payment Service & Inventory Service consume it.

3. What are challenges with microservices?

Answer:

Distributed system complexity (debugging across services is hard).

Data consistency (harder than monolith, usually eventual consistency).

Network latency & failures.

Monitoring & logging (need centralized solutions like ELK/Prometheus).

Deployment overhead (managing 10+ services isn‚Äôt fun without Docker/K8s).

4. How do you handle database in microservices?

Answer:

Each microservice should own its database ‚Üí avoids tight coupling.

Data consistency handled using Sagas / Event-driven architecture.

5. What is API Gateway in microservices?

Answer:
API Gateway is a single entry point for all microservices. It:

Routes requests to services.

Handles auth, rate limiting, logging.

Example: Netflix Zuul, Spring Cloud Gateway, NGINX.

6. How do you handle service discovery?

Answer:
Since services may scale dynamically, we need service discovery.

Eureka / Consul / Zookeeper help register and discover services automatically.

7. What is Circuit Breaker? Why use it?

Answer:
Circuit Breaker (Resilience4j/Hystrix) prevents cascading failures.

If Service A calls Service B, and B is down, the breaker opens ‚Üí avoids hammering B & returns fallback response.

8. How do you secure microservices?

Answer:

Authentication/Authorization via JWT tokens, OAuth2.

API Gateway enforces authentication.

Services trust each other via shared secrets or mTLS.

9. How do you monitor microservices?

Answer:

Logs ‚Üí ELK Stack (ElasticSearch, Logstash, Kibana).

Metrics ‚Üí Prometheus + Grafana.

Distributed Tracing ‚Üí Zipkin / Jaeger.

Major Microservice Design Patterns (Important for 2 YOE)

üî• Interviewers love these because they test if you can handle real-world problems:

Database per Service

Each service has its own DB, avoids coupling.

Communication handled via events if needed.

Saga Pattern (for distributed transactions)

Breaks down transactions into steps across services.

If one fails ‚Üí compensating action is triggered.

Example: Hotel Booking ‚Üí Payment fails ‚Üí cancel reservation.

API Gateway Pattern

Single entry for clients.

Handles routing, security, throttling.

Circuit Breaker Pattern

Protects services from failures & timeouts.

CQRS (Command Query Responsibility Segregation)

Split write operations (commands) from read queries.

Helps scale read-heavy apps.

Event Sourcing

Instead of storing current state, store sequence of events.

Rebuild state by replaying events.

Strangler Fig Pattern

Useful for migrating monolith ‚Üí microservices step by step.

‚ö° Example Interview Question with Pattern:
Q: How do you handle distributed transactions in microservices?
A: We use the Saga Pattern. For example, when placing an order:

Order Service creates order ‚Üí sends event.

Payment Service processes payment.

Inventory Service updates stock.
If payment fails, a compensating action (cancel order) is triggered.

======================================
===================================
1. What‚Äôs the difference between Monolith and Microservices?

Answer:

Monolith: Single deployable unit, tightly coupled, one database, scaling means scaling the whole app.

Microservices: Multiple small services, loosely coupled, each owns its DB, can scale independently.
‚ö° Example: In an e-commerce app: Monolith = one big app handling Orders + Payments + Inventory. Microservices = split into separate services.

2. When shouldn‚Äôt you use microservices?

Answer:

When the application is small and simple (overhead > benefits).

When team size is small (managing infra becomes too heavy).

When strong consistency is more important than scalability.

3. How do you decide the boundaries of a microservice?

Answer:

Based on business capabilities (not just CRUD tables).

Example: Payment Service, Inventory Service, Order Service.

Follow Domain-Driven Design (DDD) ‚Üí bounded contexts.

4. How do you handle backward compatibility in APIs?

Answer:

Version your APIs (/api/v1/orders).

Use feature toggles.

Maintain old APIs until clients migrate.

5. Difference between synchronous vs asynchronous communication?

Answer:

Synchronous: Request/response style ‚Üí REST, gRPC. Simple but can cause tight coupling.

Asynchronous: Event-driven ‚Üí Kafka, RabbitMQ. More scalable, resilient, decoupled.
üí° Use async for high throughput (payments, logs), sync for user-facing requests (login, profile).

6. How do you implement request-response over Kafka/RabbitMQ?

Answer:

Producer sends message with a correlation ID.

Consumer processes and replies on a reply-to queue/topic with the same correlation ID.

Producer matches response with the request.

7. Difference between REST and gRPC in microservices?

Answer:

REST: Text-based (JSON), human-readable, easy to debug, slower.

gRPC: Binary (Protobuf), faster, strongly typed, good for internal service-to-service calls.

8. What is eventual consistency?

Answer:
Data may not be updated everywhere immediately, but it will converge eventually.
üí° Example: After placing an order ‚Üí Order Service confirms instantly, but Inventory Service updates stock asynchronously.

9. How do you handle shared data between microservices?

Answer:

Don‚Äôt share DBs directly.

Use events to sync state across services.

Or use a query service (CQRS) if multiple services need read access.

10. Saga Pattern vs Two-Phase Commit (2PC)?

Answer:

2PC: Traditional DB distributed transaction. Blocking, slow, not scalable.

Saga: Breaks transaction into steps with compensating actions. Non-blocking, more scalable, widely used in microservices.

11. What is CQRS and when to use it?

Answer:

CQRS (Command Query Responsibility Segregation): Split write operations (commands) from read operations (queries).

Helps when read-heavy systems need fast queries.
üí° Example: Banking ‚Üí Writes go through validation, but reads can hit a denormalized view.

12. How do you scale a microservice horizontally?

Answer:

Deploy multiple instances behind a load balancer.

Use container orchestration (Docker + Kubernetes).

Stateless services scale easier than stateful ones.

13. Circuit Breaker vs Retry Pattern?

Answer:

Retry: Automatically retries a failed request (good for temporary glitches).

Circuit Breaker: Stops requests when a service is failing consistently ‚Üí avoids system overload.
üëâ Both can be combined: Retry first, then trip breaker if still failing.

14. How do you handle service timeouts?

Answer:

Set timeout configs in HTTP clients (e.g., RestTemplate/WebClient in Spring Boot).

Use circuit breaker with fallback response.

Use async messaging if possible.

15. What is Bulkhead Pattern?

Answer:

Inspired by ship bulkheads (sections).

Isolate resources (like thread pools, DB connections) per service ‚Üí failure in one service won‚Äôt consume all resources.
üí° Example: Payment service gets its own thread pool separate from Notification service.

16. How do you deploy multiple services together?

Answer:

Docker Compose: For local dev, run multiple containers.

Kubernetes: For production ‚Üí scaling, load balancing, auto-restarts.

CI/CD pipelines (Jenkins, GitHub Actions) automate deployments.

17. How do you handle logging across microservices?

Answer:

Use centralized logging (ELK, Graylog).

Add correlation IDs in logs to trace requests across services.

18. How do you ensure observability in microservices?

Answer:

Metrics: Prometheus, Micrometer.

Logs: ELK stack.

Tracing: Zipkin, Jaeger.

Combine all to debug distributed flows.

19. What is Strangler Fig Pattern?

Answer:

Migrate from monolith ‚Üí microservices gradually.

Wrap old system with API gateway, and slowly replace modules with microservices.

20. How do you test microservices?

Answer:

Unit tests (per service).

Contract testing (e.g., Pact) ‚Üí ensure API compatibility.

Integration testing with multiple services.

End-to-end testing via Postman/Newman or automated tools.


2phase 
1. Prepare Phase

A Coordinator (transaction manager) asks all participants (databases/services):
‚ÄúHey, can you commit this transaction?‚Äù

Each participant tries the transaction locally and replies:

Yes (Vote Commit) ‚Üí ready to commit.

No (Vote Abort) ‚Üí can‚Äôt do it.

2. Commit Phase

If all said Yes ‚Üí Coordinator tells everyone: Commit.

If anyone said No ‚Üí Coordinator tells everyone: Rollback.
